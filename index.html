<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>レイリー散乱シミュレータ</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: #fff;
            font-family: sans-serif;
        }
        canvas {
            border: 2px solid #555;
            background-color: #000;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 300px;
        }
        button {
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>レイリー散乱シミュレータ</h1>
    <canvas id="rayleighCanvas" width="800" height="450"></canvas>
    <div id="controls">
        <button id="startStopButton">スタート</button>
        <button id="blueSkyButton">青空観測モード</button>
        <button id="sunsetButton">夕焼け観測モード</button>
        <label for="sunYSlider">太陽光の高さ (0:上空, 100:地表)</label>
        <input type="range" id="sunYSlider" min="0" max="100" value="0">
        
        <label for="domeXSlider">観測ドームの位置 (0:左端, 100:右端)</label>
        <input type="range" id="domeXSlider" min="0" max="100" value="75">
        
        <label for="domeAngleSlider">観測ドームの向き (0:真左, 90:天頂)</label>
        <input type="range" id="domeAngleSlider" min="0" max="90" value="0">
        
        <label for="particleCountSlider">粒子数 (<span id="particleCountValue">200</span>)</label>
        <input type="range" id="particleCountSlider" min="200" max="2000" value="200" step="100">

        <button id="resetButton">リセット</button>
    </div>

    <script>
        const canvas = document.getElementById('rayleighCanvas');
        const ctx = canvas.getContext('2d');
        const sunYSlider = document.getElementById('sunYSlider');
        const domeXSlider = document.getElementById('domeXSlider');
        const domeAngleSlider = document.getElementById('domeAngleSlider');
        const particleCountSlider = document.getElementById('particleCountSlider');
        const particleCountValueSpan = document.getElementById('particleCountValue');
        const startStopButton = document.getElementById('startStopButton');
        const resetButton = document.getElementById('resetButton');
        const blueSkyButton = document.getElementById('blueSkyButton');
        const sunsetButton = document.getElementById('sunsetButton');


        let PARTICLE_COUNT = parseInt(particleCountSlider.value);
        let particles = [];
        const SCATTER_STRENGTH = 0.02;

        let DOME_CENTER_X = canvas.width * 0.75;
        const DOME_CENTER_Y = canvas.height * 0.95;
        const DOME_RADIUS = 30;
        const DOME_DETECT_TOLERANCE = Math.PI / 8; // ±22.5度

        let hitColors = { count: 0, hX: 0, hY: 0, s: 0, l: 0 };
        let simulationRunning = false;
        let animationFrameId = null;

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            h /= 360;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        class Particle {
            constructor() {
                this.reset();
            }

            // 波長からRGB値を生成する関数
            wavelengthToRgb(w) {
                let r, g, b;
                if (w >= 380 && w < 440) { // 紫〜青
                    r = -(w - 440) / 60;
                    g = 0;
                    b = 1;
                } else if (w >= 440 && w < 490) { // 青〜シアン
                    r = 0;
                    g = (w - 440) / 50;
                    b = 1;
                } else if (w >= 490 && w < 510) { // シアン〜緑
                    r = 0;
                    g = 1;
                    b = -(w - 510) / 20;
                } else if (w >= 510 && w < 580) { // 緑〜黄
                    r = (w - 510) / 70;
                    g = 1;
                    b = 0;
                } else if (w >= 580 && w < 645) { // 黄〜赤
                    r = 1;
                    g = -(w - 645) / 65;
                    b = 0;
                } else if (w >= 645 && w <= 780) { // 赤
                    r = 1;
                    g = 0;
                    b = 0;
                } else {
                    r = g = b = 0;
                }
                
                // 強度補正
                let factor = 0;
                if (w >= 380 && w < 420) factor = 0.3 + 0.7 * (w - 380) / 40;
                else if (w >= 420 && w < 700) factor = 1;
                else if (w >= 700 && w <= 780) factor = 0.3 + 0.7 * (780 - w) / 80;
                
                r = Math.floor(r * 255 * factor);
                g = Math.floor(g * 255 * factor);
                b = Math.floor(b * 255 * factor);
                
                return `rgb(${r},${g},${b})`;
            }

            getRgbComponents() {
                const rgb = this.color.match(/\d+/g).map(Number);
                return { r: rgb[0], g: rgb[1], b: rgb[2] };
            }

            scatter() {
                this.scattered = true;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                let angle;
                let randomVal;
                do {
                    randomVal = Math.random() * 2;
                    angle = (Math.random() * Math.PI * 2) - Math.PI;
                } while (randomVal > 1 + Math.cos(angle) * Math.cos(angle));

                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }

            update() {
                const distSq = (this.x - DOME_CENTER_X) ** 2 + (this.y - DOME_CENTER_Y) ** 2;
                if (!this.hitDome && distSq < DOME_RADIUS ** 2 && this.y < DOME_CENTER_Y) {
                    
                    const particleAngle = Math.atan2(-this.vy, -this.vx);
                    const domeVectorAngle = Math.PI + (domeAngleSlider.value / 90) * (Math.PI / 2);

                    const angleDiff = Math.abs(particleAngle - domeVectorAngle);

                    if (angleDiff < DOME_DETECT_TOLERANCE || Math.abs(angleDiff - Math.PI * 2) < DOME_DETECT_TOLERANCE) {
                        this.hitDome = true;
                        const { r, g, b } = this.getRgbComponents();
                        const [h, s, l] = rgbToHsl(r, g, b);

                        hitColors.hX += Math.cos(h * Math.PI / 180);
                        hitColors.hY += Math.sin(h * Math.PI / 180);
                        hitColors.s += s;
                        hitColors.l += l;
                        hitColors.count++;
                    }
                }

                if (this.x > canvas.width + 20 || this.x < -20 || this.y > canvas.height + 20 || this.y < -20) {
                    this.reset();
                    return;
                }
                
                const scatterProbability = this.scatterFactor * SCATTER_STRENGTH;
                
                if (!this.scattered && Math.random() < scatterProbability) {
                    this.scatter();
                }

                this.x += this.vx;
                this.y += this.vy;
            }

            reset() {
                const sunYRange = sunYSlider.value / 100;
                const initialYHeight = canvas.height * 0.2; 
                const groundLevel = canvas.height * 0.95;

                this.wavelength = this.getWavelengthFromSolarSpectrum();
                this.color = this.wavelengthToRgb(this.wavelength);
                
                const initialY = (groundLevel - initialYHeight) * sunYRange + Math.random() * initialYHeight;
                this.x = -10;
                this.y = initialY;
                
                this.vx = 1 + Math.random() * 0.5;
                this.vy = 0;
                
                this.scattered = false;
                this.scatterFactor = Math.pow(400 / this.wavelength, 4);
                this.hitDome = false;
            }

            getWavelengthFromSolarSpectrum() {
                let w;
                do {
                    w = 400 + Math.random() * 300; 
                    const solarIntensity = (w) => {
                        if (w < 400) return 0.1;
                        if (w < 480) return 0.1 + (w - 400) / 80 * 0.8;
                        if (w < 520) return 0.9 - (w - 480) / 40 * 0.2;
                        if (w < 580) return 0.7 - (w - 520) / 60 * 0.3;
                        if (w < 650) return 0.4 - (w - 580) / 70 * 0.2;
                        if (w < 700) return 0.2 - (w - 650) / 50 * 0.1;
                        return 0.1;
                    };
                    const intensity = solarIntensity(w);
                    if (Math.random() < intensity) {
                        return w;
                    }
                } while (true);
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }
        }

        function drawGround(drawGuide = false) {
            DOME_CENTER_X = canvas.width * (domeXSlider.value / 100);

            if (drawGuide) {
                const sunYRange = sunYSlider.value / 100;
                const initialYHeight = canvas.height * 0.2;
                const groundLevel = canvas.height * 0.95;
                const guideY = (groundLevel - initialYHeight) * sunYRange;
                
                ctx.fillStyle = 'rgba(150, 200, 255, 0.3)';
                ctx.fillRect(0, guideY, canvas.width, initialYHeight);
            }
            
            ctx.fillStyle = '#654321';
            ctx.fillRect(0, canvas.height * 0.96, canvas.width, canvas.height * 0.04);
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, canvas.height * 0.95, canvas.width, canvas.height * 0.01);

            // 観測ドーム
            ctx.beginPath();
            ctx.arc(DOME_CENTER_X, DOME_CENTER_Y, DOME_RADIUS, Math.PI, 0, false);
            if (hitColors.count > 0) {
                const avgH = Math.atan2(hitColors.hY, hitColors.hX) * 180 / Math.PI;
                const finalH = avgH < 0 ? avgH + 360 : avgH;
                const avgS = hitColors.s / hitColors.count;
                const avgL = hitColors.l / hitColors.count;
                const [r, g, b] = hslToRgb(finalH, avgS, avgL);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
            } else {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
            }
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();

            // 検出範囲の描画
            const currentDomeAngle = Math.PI + (domeAngleSlider.value / 90) * (Math.PI / 2);
            const startAngle = currentDomeAngle - DOME_DETECT_TOLERANCE;
            const endAngle = currentDomeAngle + DOME_DETECT_TOLERANCE;

            ctx.beginPath();
            ctx.moveTo(DOME_CENTER_X, DOME_CENTER_Y);
            ctx.arc(DOME_CENTER_X, DOME_CENTER_Y, DOME_RADIUS * 1.5, startAngle, endAngle, false);
            ctx.closePath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function resetSimulation() {
            PARTICLE_COUNT = parseInt(particleCountSlider.value);
            initParticles();
            hitColors = { count: 0, hX: 0, hY: 0, s: 0, l: 0 };
            
            if (!simulationRunning) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround(true);
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGround(false);

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            if (simulationRunning) {
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        function startSimulation() {
            if (!simulationRunning) {
                simulationRunning = true;
                startStopButton.textContent = 'ストップ';
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                resetSimulation();
                animate();
            } else {
                simulationRunning = false;
                startStopButton.textContent = 'スタート';
                cancelAnimationFrame(animationFrameId);
            }
        }

        // イベントリスナー
        startStopButton.addEventListener('click', startSimulation);
        resetButton.addEventListener('click', resetSimulation);

        blueSkyButton.addEventListener('click', () => {
            sunYSlider.value = 15; // 修正: 上から15%
            domeXSlider.value = 10; // 修正: 左から10%
            domeAngleSlider.value = 90;
            if (simulationRunning) {
                resetSimulation();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround(true);
            }
            startSimulation();
        });

        sunsetButton.addEventListener('click', () => {
            sunYSlider.value = 100;
            domeXSlider.value = 95;
            domeAngleSlider.value = 0;
            if (simulationRunning) {
                resetSimulation();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround(true);
            }
            startSimulation();
        });


        particleCountSlider.addEventListener('input', () => {
            particleCountValueSpan.textContent = particleCountSlider.value;
            if (simulationRunning) {
                 resetSimulation();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround(true);
            }
        });
        sunYSlider.addEventListener('input', () => {
            if (simulationRunning) {
                resetSimulation();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround(true);
            }
        });
        domeXSlider.addEventListener('input', () => {
            if (simulationRunning) {
                hitColors = { count: 0, hX: 0, hY: 0, s: 0, l: 0 };
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGround(true);
        });
        domeAngleSlider.addEventListener('input', () => {
            if (simulationRunning) {
                hitColors = { count: 0, hX: 0, hY: 0, s: 0, l: 0 };
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGround(true);
        });

        // 初回描画
        drawGround(true);
    </script>
</body>
</html>